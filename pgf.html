<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PGF Calc Pro</title>
<!-- PWA -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#222222">
<!-- iOS PWA -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="PGF Calc">
<style>
  /* --- Reset & Base --- */
  body {
    background-color: #000;
    color: #fff;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    padding: 15px 10px;
    text-align: center;
    box-sizing: border-box;
    overscroll-behavior: none;
  }
  *, *:before, *:after { box-sizing: inherit; }

  /* --- Inputs --- */
  input {
    font-size: 16px !important;
    font-weight: bold;
    text-align: center;
    background: #fff;
    color: #000;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 100%;
    height: 34px;
    -webkit-appearance: none;
    margin: 0;
  }
  input:focus { outline: none; }
  input::placeholder { color: #bbb; font-weight: normal; }
  /* Remove number input spinners globally */
  input[type=number]::-webkit-inner-spin-button,
  input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
  input[type=number] { -moz-appearance: textfield; }

  /* --- Layout Components --- */
  .row { display: flex; width: 100%; gap: 0; }
  .panel {
    background: #222;
    border: 1px solid #444;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    margin: -1px 0 0 -1px; /* Border collapse hack */
    position: relative;
    padding: 4px;
  }
  
  /* --- Colors --- */
  .bg-accent { background-color: #102A4A !important; border-color: #1E3E66 !important; z-index: 1; }
  .bg-header { background-color: #1a1a1a !important; border-color: #333 !important; }
  .txt-green { color: #666; font-weight: bold; }
  .txt-orange { color: #FF9800; font-weight: bold; }
  .txt-white { color: #fff; font-weight: bold; }
  .lbl-sm { font-size: 12px; color: #ccc; margin-bottom: 2px; }
  .fs-14 { font-size: 14px !important; }

  /* --- Main Grid (Scrollable) --- */
  .grid-wrapper {
    position: relative;
    border: 1px solid #444;
    border-radius: 10px;
    overflow: hidden; /* Contains the scroll */
    background: #222;
  }
  .scroll-container {
    display: grid;
    /* All columns: 100px each */
    grid-template-columns: 100px repeat(4, 100px);
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    max-width: 100%;
  }
  .grid-wrapper.reversed .scroll-container {
    grid-template-columns: repeat(4, 100px) 100px;
  }

  /* Grid Items */
  .cell-h { height: 68px; } /* Data row height */
  .cell-m { height: 50px; } /* Header row height */

  /* --- Input Group (Result + Input + Diff) --- */
  .res-line { line-height: 1.3; display: block; min-height: 22px; font-size: 14px; padding: 2px 0; }
  .inp-group { position: relative; width: 100%; margin: 2px 0; }
  .inp-sm { height: 34px; font-size: 16px !important; padding-right: 28px; }
  .btn-clear {
    position: absolute; right: 0; top: 0; height: 34px; width: 28px;
    background: transparent; border: none; color: #888; font-size: 24px;
    font-weight: bold; cursor: pointer; display: none; align-items: center; justify-content: center;
    line-height: 34px; padding: 0;
  }
  .btn-clear.show {
    display: flex;
  }
  .diff-line {
    display: block; min-height: 22px; white-space: nowrap;
    font-size: 14px; font-weight: bold; padding: 2px 0;
  }

  /* --- Slope / Distance inputs: dark theme --- */
  .int-slope-inp input,
  .int-dist-cell input {
    background: #333;
    color: #e0e0e0;
    border-color: #555;
    border-radius: 0;
    border-right: none;
  }
  .int-slope-inp input::placeholder,
  .int-dist-cell input::placeholder { color: #777; }
  .int-slope-inp input:focus,
  .int-dist-cell input:focus { outline: none; }

  /* --- Integrated Section (Slope + SVG + Distances) --- */
  .int-cell {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    background: #222;
    border-top: 1px solid #444;
    border-bottom: 1px solid #444;
  }
  .int-top {
    display: flex;
    align-items: center;
    padding: 20px 0 0 0;
  }
  .int-slope-inp {
    width: 100px;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .int-bottom {
    display: flex;
    padding-bottom: 2px;
  }
  .int-dist-cell {
    width: 100px;
    min-width: 100px;
    height: 34px;
    background: transparent;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }

  /* --- Footer Buttons --- */
  .footer { display: flex; gap: 8px; margin-top: 15px; height: 50px; }

  /* --- Formula Display --- */
  .formula {
    margin-top: 15px;
    padding: 10px 14px;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 6px;
    text-align: left;
    font-size: 11px;
    color: #777;
    line-height: 1.8;
  }
  .formula span { color: #aaa; }
  .btn {
    flex: 1; border: none; border-radius: 8px;
    font-weight: bold; font-size: 14px; color: #fff; cursor: pointer;
  }
  .btn-reset { background: #444; color: #ccc; }
  .btn-flip { background: #666; }

</style>
</head>
<body>

  <div class="grid-wrapper">
    <div class="scroll-container" id="mainGrid">
      </div>
  </div>

  <div class="footer">
    <button class="btn btn-reset" onclick="doReset()">読値リセット</button>
    <button class="btn btn-flip" onclick="doFlip()">観測点変更</button>
  </div>
  <div class="formula">
    <span>累積落差 (mm)</span>　＝　距離 (m) × 勾配 (%) × 10　　※スパンごとに加算<br>
    <span>目標値</span>　＝　基準読み値 − 累積落差<br>
    <span>差分</span>　＝　目標値 − 実測値　　( + → 高い　/ − → 低い )
  </div>

<script>
/* --- Logic --- */

// Configuration
const SPANS = 4; // Number of spans to generate
let isReversed = false; // Observation point direction: false = 上り側から, true = 下り側から

// Initialize
window.onload = function() {
  generateGrid();
  runCalc();
};

function chkEnt(e) {
  if (e.key === 'Enter' || e.keyCode === 13) e.target.blur();
}

function generateGrid() {
  const grid = document.getElementById('mainGrid');
  const wrapper = document.querySelector('.grid-wrapper');
  
  // Update wrapper class for reversed layout
  if (isReversed) {
    wrapper.classList.add('reversed');
  } else {
    wrapper.classList.remove('reversed');
  }
  
  let html = '';
  
  // Determine column order based on observation direction
  const spanOrder = isReversed ? Array.from({length: SPANS}, (_, i) => SPANS - i) : Array.from({length: SPANS}, (_, i) => i + 1);

  // 1. Integrated section (settings): slope inputs (top) + SVG (middle) + distances (bottom)
  // Cascade rule: slope entered at span i applies to span i and all subsequent spans
  let slopeCellsHtml = '';
  for (let k = 0; k < spanOrder.length; k++) {
    const idx = spanOrder[k];
    slopeCellsHtml += `<div class="int-slope-inp">
      <div class="inp-group">
        <input type="number" id="val_slope_${idx}" class="inp-sm" placeholder="0" step="0.1" oninput="onSlopeInput(${idx})" onkeydown="chkEnt(event)">
        <button class="btn-clear" onclick="clearSlope(${idx})">×</button>
      </div>
    </div>`;
  }
  // 50px label spacer: centered on reference dot, label text identifies the row
  const slopeSpacer = `<div style="width:50px;min-width:50px;height:34px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;"><span style="font-size:10px;color:#aaa;line-height:1.3;">勾配<br>(%)</span></div>`;
  const distSpacer  = `<div style="width:50px;min-width:50px;height:34px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;"><span style="font-size:10px;color:#aaa;line-height:1.3;">距離<br>(m)</span></div>`;

  html += `<div class="int-cell">
    <div class="int-top">${slopeSpacer}${slopeCellsHtml}</div>
    <div class="int-bottom">${distSpacer}`;
  for(let idx of spanOrder) {
    html += `<div class="int-dist-cell">
        <div class="inp-group">
          <input type="number" id="in_dist_${idx}" class="inp-sm" placeholder="5" oninput="onDistInput(${idx})" onkeydown="chkEnt(event)">
          <button class="btn-clear" onclick="clearDist(${idx})">×</button>
        </div>
      </div>`;
  }
  html += `</div>
    <svg id="slope-svg" width="500" height="90" style="display:block"></svg>
    </div>`;

  // 2. Back Row (奥) - readings
  if (isReversed) {
    for(let idx of spanOrder) {
      html += `
        <div class="panel cell-h">
          <div class="inp-group">
            <input type="number" id="in_rb_${idx}" class="inp-sm" placeholder="読値" oninput="chkDiff('rb', ${idx})" onkeydown="chkEnt(event)">
            <button class="btn-clear" onclick="clearInp('in_rb_${idx}')">×</button>
          </div>
          <div style="display:flex;width:100%;justify-content:space-between;align-items:center;height:26px;">
            <span id="out_rb_${idx}" class="res-line txt-green">-</span>
            <span id="diff_rb_${idx}" class="diff-line" style="color:#888">-</span>
          </div>
        </div>`;
    }
    html += `<div class="panel cell-h"><input type="number" id="val_rb" class="inp-sm" placeholder="読値" oninput="runCalc()" onkeydown="chkEnt(event)"><div style="height:26px;width:100%"></div></div>`;
  } else {
    html += `<div class="panel cell-h"><input type="number" id="val_rb" class="inp-sm" placeholder="読値" oninput="runCalc()" onkeydown="chkEnt(event)"><div style="height:26px;width:100%"></div></div>`;
    for(let idx of spanOrder) {
      html += `
        <div class="panel cell-h">
          <div class="inp-group">
            <input type="number" id="in_rb_${idx}" class="inp-sm" placeholder="読値" oninput="chkDiff('rb', ${idx})" onkeydown="chkEnt(event)">
            <button class="btn-clear" onclick="clearInp('in_rb_${idx}')">×</button>
          </div>
          <div style="display:flex;width:100%;justify-content:space-between;align-items:center;height:26px;">
            <span id="out_rb_${idx}" class="res-line txt-green">-</span>
            <span id="diff_rb_${idx}" class="diff-line" style="color:#888">-</span>
          </div>
        </div>`;
    }
  }

  // 3. Front Row (手前) - readings
  if (isReversed) {
    for(let idx of spanOrder) {
      html += `
        <div class="panel cell-h">
          <div class="inp-group">
            <input type="number" id="in_rf_${idx}" class="inp-sm" placeholder="読値" oninput="chkDiff('rf', ${idx})" onkeydown="chkEnt(event)">
            <button class="btn-clear" onclick="clearInp('in_rf_${idx}')">×</button>
          </div>
          <div style="display:flex;width:100%;justify-content:space-between;align-items:center;height:26px;">
            <span id="out_rf_${idx}" class="res-line txt-green">-</span>
            <span id="diff_rf_${idx}" class="diff-line" style="color:#888">-</span>
          </div>
        </div>`;
    }
    html += `<div class="panel cell-h"><input type="number" id="val_rf" class="inp-sm" placeholder="読値" oninput="runCalc()" onkeydown="chkEnt(event)"><div style="height:26px;width:100%"></div></div>`;
  } else {
    html += `<div class="panel cell-h"><input type="number" id="val_rf" class="inp-sm" placeholder="読値" oninput="runCalc()" onkeydown="chkEnt(event)"><div style="height:26px;width:100%"></div></div>`;
    for(let idx of spanOrder) {
      html += `
        <div class="panel cell-h">
          <div class="inp-group">
            <input type="number" id="in_rf_${idx}" class="inp-sm" placeholder="読値" oninput="chkDiff('rf', ${idx})" onkeydown="chkEnt(event)">
            <button class="btn-clear" onclick="clearInp('in_rf_${idx}')">×</button>
          </div>
          <div style="display:flex;width:100%;justify-content:space-between;align-items:center;height:26px;">
            <span id="out_rf_${idx}" class="res-line txt-green">-</span>
            <span id="diff_rf_${idx}" class="diff-line" style="color:#888">-</span>
          </div>
        </div>`;
    }
  }

  grid.innerHTML = html;
}

// Cascade: slope entered at span i applies to i and all subsequent spans (1→4 order)
function getEffectiveSlopes() {
  const slopes = [];
  let last = 0;
  for (let i = 1; i <= SPANS; i++) {
    const el = document.getElementById(`val_slope_${i}`);
    if (el && el.value !== '') last = parseFloat(el.value);
    slopes.push(last);
  }
  return slopes; // slopes[0]=span1, slopes[1]=span2, ...
}

// Main Calculation
let memTargets = {}; // Store calculated targets

function runCalc() {
  const h = 0;
  const effectiveSlopes = getEffectiveSlopes();

  // Get Readings (NaN if empty)
  const rb = document.getElementById('val_rb').value === '' ? NaN : parseFloat(document.getElementById('val_rb').value);
  const rf = document.getElementById('val_rf').value === '' ? NaN : parseFloat(document.getElementById('val_rf').value);

  // Calculate Points
  memTargets = {}; // Reset memory

  let cumDrop = 0;
  for(let i=1; i<=SPANS; i++) {
    const dEl = document.getElementById(`in_dist_${i}`);
    const dVal = dEl ? (dEl.value === '' ? 5 : parseFloat(dEl.value)) : 5;
    cumDrop += dVal * 1000 * (effectiveSlopes[i-1] / 100);

    // Formula: 目標値 = 基準値(奥or手前) - 累積drop + PGF高
    const drop = cumDrop;

    // --- Back Row ---
    const elOutRb = document.getElementById(`out_rb_${i}`);
    if(!isNaN(rb)) {
      const val = Math.round(rb - drop + h);
      memTargets[`rb_${i}`] = val;
      elOutRb.innerText = val;
      chkDiff('rb', i);
    } else {
      elOutRb.innerText = '-';
      const dRb = document.getElementById(`diff_rb_${i}`); dRb.innerText = '-'; dRb.style.color = '#888';
    }

    // --- Front Row ---
    const elOutRf = document.getElementById(`out_rf_${i}`);
    if(!isNaN(rf)) {
      const val = Math.round(rf - drop + h);
      memTargets[`rf_${i}`] = val;
      elOutRf.innerText = val;
      chkDiff('rf', i);
    } else {
      elOutRf.innerText = '-';
      const dRf = document.getElementById(`diff_rf_${i}`); dRf.innerText = '-'; dRf.style.color = '#888';
    }
  }

  drawSlope();
}

function chkDiff(type, idx) {
  const key = `${type}_${idx}`;
  const target = memTargets[key];
  const inpEl = document.getElementById(`in_${key}`);
  const outEl = document.getElementById(`diff_${key}`);
  const clearBtn = inpEl?.parentElement?.querySelector('.btn-clear');

  // Toggle clear button visibility
  if(clearBtn) {
    if(inpEl.value !== '') {
      clearBtn.classList.add('show');
    } else {
      clearBtn.classList.remove('show');
    }
  }

  if(target === undefined || inpEl.value === '') {
    outEl.innerText = '-';
    outEl.style.color = '#888';
    return;
  }

  const actual = parseFloat(inpEl.value);
  const diff = target - actual;

  // Diff Logic:
  // Target 1000, Actual 900. Diff +100.
  // Actual is smaller -> Ground is higher -> Need to Cut/Lower -> ▼
  // Target 1000, Actual 1100. Diff -100.
  // Actual is bigger -> Ground is lower -> Need to Fill/Raise -> ▲

  if(diff > 0) {
    outEl.innerText = Math.abs(diff) + ' 高い';
    outEl.style.color = '#f44336';
  } else if (diff < 0) {
    outEl.innerText = Math.abs(diff) + ' 低い';
    outEl.style.color = '#2196F3';
  } else {
    outEl.innerText = 'OK';
    outEl.style.color = '#FFD600';
  }
}

function clearInp(id) {
  const el = document.getElementById(id);
  if(el) {
    el.value = '';
    // Trigger input event manually or just call chk
    // id format: in_rb_1
    const parts = id.split('_'); // [in, rb, 1]
    chkDiff(parts[1], parts[2]);
    el.focus();
    // Clear button will be hidden by chkDiff function
  }
}

function drawSlope() {
  const svgEl = document.getElementById('slope-svg');
  if (!svgEl) return;

  const effectiveSlopes = getEffectiveSlopes();

  const W = 500, H = 90;
  const pad = 50;
  const usableW = W - 2 * pad; // 400px
  const tickTop = 8, tickBot = 22, arrowY = 15;
  const centerY = 58;

  svgEl.setAttribute('height', H);

  // Fixed equal spacing regardless of distance values
  const step = usableW / SPANS; // 100px per span

  // Build points array
  let pts = [];
  let cumYDrop = 0;
  if (!isReversed) {
    pts.push({ x: pad, y: centerY, isRef: true });
    for (let i = 0; i < SPANS; i++) {
      cumYDrop += step * (effectiveSlopes[i] / 100);
      pts.push({ x: pad + step * (i + 1), y: centerY - cumYDrop, isRef: false });
    }
  } else {
    pts.push({ x: W - pad, y: centerY, isRef: true });
    for (let i = 0; i < SPANS; i++) {
      cumYDrop += step * (effectiveSlopes[i] / 100);
      pts.push({ x: W - pad - step * (i + 1), y: centerY - cumYDrop, isRef: false });
    }
  }

  // Clamp y to slope area
  const yMin = tickBot + 8, yMax = H - 6;
  pts.forEach(p => { p.y = Math.max(yMin, Math.min(yMax, p.y)); });

  // x positions sorted left to right for dimension arrows
  const xPos = pts.map(p => p.x).sort((a, b) => a - b);

  let svg = '';

  // Dimension arrows
  const aw = 7, ah = 4; // arrowhead width / half-height
  for (let i = 0; i < xPos.length - 1; i++) {
    const x1 = xPos[i], x2 = xPos[i + 1];

    // Tick marks
    svg += `<line x1="${x1.toFixed(1)}" y1="${tickTop}" x2="${x1.toFixed(1)}" y2="${tickBot}" stroke="#e0e0e0" stroke-width="0.5"/>`;
    if (i === xPos.length - 2) {
      svg += `<line x1="${x2.toFixed(1)}" y1="${tickTop}" x2="${x2.toFixed(1)}" y2="${tickBot}" stroke="#e0e0e0" stroke-width="0.5"/>`;
    }

    // Dimension baseline
    if (x2 - x1 > aw * 2) {
      svg += `<line x1="${(x1 + aw).toFixed(1)}" y1="${arrowY}" x2="${(x2 - aw).toFixed(1)}" y2="${arrowY}" stroke="#e0e0e0" stroke-width="0.5"/>`;
    }

    // Arrowheads (inward-pointing)
    svg += `<polygon points="${x1},${arrowY} ${x1+aw},${arrowY-ah} ${x1+aw},${arrowY+ah}" fill="#aaa"/>`;
    svg += `<polygon points="${x2},${arrowY} ${x2-aw},${arrowY-ah} ${x2-aw},${arrowY+ah}" fill="#aaa"/>`;
  }

  // Horizontal reference line (dashed)
  svg += `<line x1="${pad}" y1="${centerY}" x2="${W - pad}" y2="${centerY}" stroke="rgba(255,255,255,0.2)" stroke-width="1" stroke-dasharray="3,3"/>`;

  // Drop lines from each dot to the bottom edge
  for (const p of pts) {
    svg += `<line x1="${p.x.toFixed(1)}" y1="${p.y.toFixed(1)}" x2="${p.x.toFixed(1)}" y2="${H}" stroke="rgba(255,255,255,0.25)" stroke-width="1" stroke-dasharray="4,3"/>`;
  }

  // Slope line
  const lineCoords = pts.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
  svg += `<polyline points="${lineCoords}" fill="none" stroke="#2196F3" stroke-width="2" stroke-linejoin="round"/>`;

  // Dots
  for (const p of pts) {
    if (p.isRef) {
      svg += `<circle cx="${p.x.toFixed(1)}" cy="${p.y.toFixed(1)}" r="5" fill="#f44336" stroke="#111" stroke-width="0.5"/>`;
    } else {
      svg += `<circle cx="${p.x.toFixed(1)}" cy="${p.y.toFixed(1)}" r="4" fill="#FFD600" stroke="#111" stroke-width="0.5"/>`;
    }
  }

  svgEl.innerHTML = svg;
}

function updateSlopePlaceholders() {
  let hasValue = false;
  for (let i = 1; i <= SPANS; i++) {
    const el = document.getElementById(`val_slope_${i}`);
    if (!el) continue;
    if (el.value !== '') {
      hasValue = true;
    } else {
      el.placeholder = hasValue ? '=' : '0';
    }
  }
}

function onSlopeInput(idx) {
  const el = document.getElementById(`val_slope_${idx}`);
  const clearBtn = el?.parentElement?.querySelector('.btn-clear');
  if(clearBtn) clearBtn.classList.toggle('show', el.value !== '');
  updateSlopePlaceholders();
  runCalc();
}

function clearSlope(idx) {
  const el = document.getElementById(`val_slope_${idx}`);
  if(el) {
    el.value = '';
    const clearBtn = el.parentElement?.querySelector('.btn-clear');
    if(clearBtn) clearBtn.classList.remove('show');
    updateSlopePlaceholders();
    runCalc();
    el.focus();
  }
}

function onDistInput(idx) {
  const el = document.getElementById(`in_dist_${idx}`);
  const clearBtn = el?.parentElement?.querySelector('.btn-clear');
  if(clearBtn) {
    clearBtn.classList.toggle('show', el.value !== '');
  }
  runCalc();
}

function clearDist(idx) {
  const el = document.getElementById(`in_dist_${idx}`);
  if(el) {
    el.value = '';
    const clearBtn = el.parentElement?.querySelector('.btn-clear');
    if(clearBtn) clearBtn.classList.remove('show');
    runCalc();
    el.focus();
  }
}

function doReset() {
  // Clear reading inputs (基準点の読値)
  document.getElementById('val_rb').value = '';
  document.getElementById('val_rf').value = '';
  
  // Clear all reading value inputs (各地点の読値)
  const inputs = document.querySelectorAll('input');
  inputs.forEach(el => {
    if(!el.id.startsWith('val_') && !el.id.startsWith('in_dist_')) { // Reading value inputs
      el.value = '';
    }
  });
  
  // Clear all calculation results and differences
  memTargets = {};
  for(let i=1; i<=SPANS; i++) {
    // Clear back row results
    document.getElementById(`out_rb_${i}`).innerText = '-';
    document.getElementById(`diff_rb_${i}`).innerText = '-';
    // Clear front row results
    document.getElementById(`out_rf_${i}`).innerText = '-';
    document.getElementById(`diff_rf_${i}`).innerText = '-';
    // Hide clear buttons
    chkDiff('rb', i);
    chkDiff('rf', i);
  }
  
  // Recalculate to update distance labels based on settings
  runCalc();
}

function doFlip() {
  // Toggle observation direction
  isReversed = !isReversed;
  
  // Save current input values before regenerating grid
  const rbValue = document.getElementById('val_rb')?.value || '';
  const rfValue = document.getElementById('val_rf')?.value || '';
  
  // Save all reading values (back and front rows)
  const readingValues = {};
  for(let i=1; i<=SPANS; i++) {
    const rbReading = document.getElementById(`in_rb_${i}`)?.value || '';
    const rfReading = document.getElementById(`in_rf_${i}`)?.value || '';
    readingValues[`rb_${i}`] = rbReading;
    readingValues[`rf_${i}`] = rfReading;
  }

  // Save distance values
  const distValues = {};
  for(let i=1; i<=SPANS; i++) {
    distValues[i] = document.getElementById(`in_dist_${i}`)?.value || '';
  }

  // Save slope values
  const slopeVals = {};
  for(let i=1; i<=SPANS; i++) {
    slopeVals[i] = document.getElementById(`val_slope_${i}`)?.value || '';
  }

  // Regenerate grid with new layout
  generateGrid();
  
  // Restore input values (swap back and front)
  // Swap reading values: back gets front, front gets back
  if (rfValue) document.getElementById('val_rb').value = rfValue;
  if (rbValue) document.getElementById('val_rf').value = rbValue;
  
  // Restore reading values (swap back and front)
  for(let i=1; i<=SPANS; i++) {
    // Swap: back row gets front values, front row gets back values
    if (readingValues[`rf_${i}`]) {
      document.getElementById(`in_rb_${i}`).value = readingValues[`rf_${i}`];
    }
    if (readingValues[`rb_${i}`]) {
      document.getElementById(`in_rf_${i}`).value = readingValues[`rb_${i}`];
    }
  }
  
  // Restore distance values
  for(let i=1; i<=SPANS; i++) {
    const el = document.getElementById(`in_dist_${i}`);
    if(el) {
      el.value = distValues[i];
      const clearBtn = el.parentElement?.querySelector('.btn-clear');
      if(clearBtn) clearBtn.classList.toggle('show', distValues[i] !== '');
    }
  }

  // Restore slope values
  for(let i=1; i<=SPANS; i++) {
    const slopeEl = document.getElementById(`val_slope_${i}`);
    if(slopeEl && slopeVals[i] !== '') {
      slopeEl.value = slopeVals[i];
      const clearBtn = slopeEl.parentElement?.querySelector('.btn-clear');
      if(clearBtn) clearBtn.classList.add('show');
    }
  }

  // Recalculate with new layout
  runCalc();
  
  // Recalculate differences for all restored reading values
  for(let i=1; i<=SPANS; i++) {
    if (readingValues[`rf_${i}`]) {
      chkDiff('rb', i);
    }
    if (readingValues[`rb_${i}`]) {
      chkDiff('rf', i);
    }
  }
}
</script>
<script>
  // Service Worker 登録（HTTPS環境でのみ動作）
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(() => {});
    });
  }
  // iOSバウンス防止
  document.addEventListener('touchmove', (e) => {
    let el = e.target;
    while (el && el !== document.documentElement) {
      if (el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth) return;
      el = el.parentElement;
    }
    e.preventDefault();
  }, { passive: false });
</script>
</body>
</html>